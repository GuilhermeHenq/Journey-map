import React, { useEffect, useState } from "react";
import { createRoot } from "react-dom/client";
import { Stage, Layer, Rect, Circle } from "react-konva";
import axios from "axios";
import "./index.css";

const showAlert = () => {
  alert("Seu progresso foi salvo!");
};

function adjustPositionToInterval(x, interval) {
  const adjustedX = Math.floor(x / interval) * interval + 10;
  return adjustedX;
}

function adjustCircleXToInterval(x) {
  const interval = 71;
  const startX = 30;
  const adjustedX = Math.floor((x - startX) / interval) * interval + startX;
  return adjustedX;
}


const dataToPost = {
  journeyPhaseData: rects[0],
  thoughtData: rects[1],
  userActionData: rects[2],
  contactPointData: rects[3],
  emotionData: circle,
};


const App = () => {
  const [rects, setRects] = useState([]);
  const [circle, setCircle] = useState({});

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [
          journeyData,
          thoughtData,
          userActionData,
          contactPointData,
          emotionData,
        ] = await Promise.all([
          axios.get("http://localhost:8080/index.php?controller=journeyPhase&method=getAllItems"),
          axios.get("http://localhost:8080/index.php?controller=thought&method=getAllItems"),
          axios.get("http://localhost:8080/index.php?controller=userAction&method=getAllItems"),
          axios.get("http://localhost:8080/index.php?controller=contactPoint&method=getAllItems"),
          axios.get("http://localhost:8080/index.php?controller=emotion&method=getAllItems"),
        ]);

        // Defina os retângulos e o círculo iniciais com base nos dados da API
        const initialRectX1 = journeyData.data[0] || {};
        const initialRectX2 = emotionData.data[0] || {};
        const initialRectX3 = userActionData.data[0] || {};
        const initialRectX4 = contactPointData.data[0] || {};
        const initialCircle = thoughtData.data[0] || {};

        setRects([initialRectX1, initialRectX2, initialRectX3, initialRectX4]);
        setCircle(initialCircle);
      } catch (error) {
        console.error("Erro ao buscar os dados:", error);
      }
    };

    fetchData();
  }, []);




  const handleDragMove = (e) => {
    const id = e.target.id();
    const newX = e.target.x();

    const updatedRects = rects.map((rect) => {
      if (rect.id === id) {
        return {
          ...rect,
          x: newX,
        };
      }
      return rect;
    });

    setRects(updatedRects);
  };

  const handleCircleDragMove = (e) => {
    const newX = e.target.x();
    const newY = Math.min(330, Math.max(261, e.target.y()));

    setCircle({
      ...circle,
      x: newX,
      y: newY,
    });
  };

  const handleDragEnd = (e) => {
    const id = e.target.id();
    const newX = e.target.x();

    if (newX >= 0 && newX <= 140) {
      e.target.x(10);
    } else if (newX >= 141 && newX <= 280) {
      e.target.x(150);
    } else if (newX >= 281 && newX <= 420) {
      e.target.x(290);
    } else if (newX >= 421 && newX <= 540) {
      e.target.x(430);
    }

    const updatedRects = rects.map((rect) => {
      if (rect.id === id) {
        return {
          ...rect,
          x: e.target.x(),
        };
      }
      return rect;
    });

    setRects(updatedRects);
  };

  const handleSaveClick = () => {
    const dataToPost = {
      journeyPhaseData,
      thoughtData,
      userActionData,
      contactPointData,
      emotionData,
    };
  
    axios
      .post("http://localhost:8080/index.php?controller=journeyPhase&method=postAllItems", dataToPost.journeyPhaseData)
      .then(() => {
        return axios.post("http://localhost:8080/index.php?controller=thought&method=postAllItems", dataToPost.thoughtData);
      })
      .then(() => {
        return axios.post("http://localhost:8080/index.php?controller=userAction&method=postAllItems", dataToPost.userActionData);
      })
      .then(() => {
        return axios.post("http://localhost:8080/index.php?controller=contactPoint&method=postAllItems", dataToPost.contactPointData);
      })
      .then(() => {
        return axios.post("http://localhost:8080/index.php?controller=emotion&method=postAllItems", dataToPost.emotionData);
      })
      .then(() => {
        console.log("Dados salvos com sucesso!");
        showAlert();
      })
      .catch((error) => {
        console.error("Erro ao salvar os dados:", error);
      });
  };
  



return (
  <div>
    <div style={{ textAlign: "center", padding: "10px", background: "#ffffff", fontFamily: "sans-serif", fontSize: "30px" }}>
      Journey Map Spike - React and Konva test
    </div>
    <div style={{ textAlign: "center", padding: "10px", background: "#d3d3d3", fontFamily: "sans-serif", fontSize: "30px" }}>
      FasesX: {rects[0].x} | AçõesX: {rects[1].x} | EmoçõesX: {circle.x} | EmoçõesY: {circle.y} | PensamentosX: {rects[2].x} | PontosX: {rects[3].x}
    </div>
    <div style={{ background: "repeating-linear-gradient(0deg,#d3d3d3,#d3d3d3 100px,white 100px,white 200px)" }}>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          {rects.map((rect) => (
            <Rect
              key={rect.id}
              id={rect.id}
              x={rect.x}
              y={rect.y}
              width={rect.width}
              height={85}
              fill={rect.color}
              opacity={1}
              draggable={true}
              onDragMove={handleDragMove}
              onDragEnd={handleDragEnd}
              dragBoundFunc={(pos) => ({
                x: Math.min(1410, Math.max(0, pos.x)),
                y: rect.y,
              })}
            />
          ))}
          <Circle
            key={circle.id}
            id={circle.id}
            x={circle.x}
            y={circle.y}
            radius={circle.radius}
            fill={circle.color}
            opacity={1}
            draggable={true}
            onDragMove={handleCircleDragMove}
            dragBoundFunc={(pos) => ({
              x: adjustCircleXToInterval(pos.x), // Use a função para ajustar a posição do RedCircle
              y: Math.min(330, Math.max(261, pos.y)),
            })}
          />
        </Layer>
      </Stage>
    </div>
    <div className="footer">
      <button className="button save" id="saveButton" onClick={() => { handleSaveClick(); showAlert(); }}>
        Salvar
      </button>
    </div>
  </div>
);
};


createRoot(document.getElementById("root")).render(<App />);
